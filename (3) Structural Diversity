#  This code is based on the work of Morgenroth et al. (2020) (DOI: 10.3390/f11020135)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import gaussian_kde

df = pd.read_csv("cleaned_master.csv", low_memory=False)
excluded_cities = ['Maple Ridge', 'New Westminster', 'Peterborough', 'Halifax']
df = df[~df['City'].isin(excluded_cities)]

# Ensure DBH is numeric and drop NaN values
df['DBH'] = pd.to_numeric(df['DBH'], errors='coerce')
df = df.dropna(subset=['DBH'])

# Create bins
bins = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, np.inf]
n_classes = 11 # Number of DBH classes for each city

# Define cities
cities = df['City'].unique()

## Create histograms for the DBH distributions of each city (Urban Forest Diameter Class Distributions)
# Loop over each city to create histograms and curve plots
for city in cities:
    city_data = df[df['City'] == city]

    if len(city_data) == 0:
        continue  # Skip if there are no valid DBH values for the city

    # Create histogram with custom bins
    plt.figure(figsize=(8, 6))

    # Restrict x-axis to maximum of 150 cm
    sns.histplot(city_data['DBH'], bins=bins, kde=False, color='skyblue')

    # Fit and plot the KDE (Kernel Density Estimate) curve
    kde = gaussian_kde(city_data['DBH'])

    # Restrict the x-range for the KDE to be within the defined bin range
    x_range = np.linspace(0, 150, 1000)  # Limit the KDE to 150 cm
    plt.plot(x_range, kde(x_range) * len(city_data['DBH']) * (bins[1] - bins[0]), color='red', lw=2)

    # Set x-axis limit to match the bins
    plt.xlim(0, 150)

    # Add titles and labels
    plt.title(f'DBH Histogram with Curve for {city}')
    plt.xlabel('DBH (cm)')
    plt.ylabel('Frequency')

    # Show the plot
    plt.show()

## Comparison of Diameter Class Distributions Against Ideal Distributions

## Structural Diversity Index
def calculate_shannon_wiener(city_data, bins, n_classes):
    # Classify trees into DBH classes using binning
    dbh_classes = pd.cut(city_data['DBH'], bins=bins, labels=range(1, len(bins)))

    # Calculate the proportion of trees in each class
    class_counts = dbh_classes.value_counts(normalize=True).sort_index()

    # Filter out zero proportions to avoid log(0)
    class_proportions = class_counts[class_counts > 0]

    # Calculate the Shannon-Wiener index (H)
    H = -np.sum(class_proportions * np.log(class_proportions))

    # Calculate H_max (maximum possible diversity)
    H_max = np.log(n_classes)

    return H, H_max


# Calculate Shannon-Wiener index for each city
city_results = []

cities = df['City'].unique()
for city in cities:
    city_data = df[df['City'] == city]

    if len(city_data) == 0:
        continue  # Skip if there are no valid DBH values for the city

    H, H_max = calculate_shannon_wiener(city_data, bins, n_classes)

    # Store the result for the city
    city_results.append({
        'City': city,
        'Shannon-Wiener Index (H)': H,
        'Maximum Diversity (H_max)': H_max
    })

# Convert results to a DataFrame for easy viewing
Structural_Diversity_Index_df = pd.DataFrame(city_results)
print(Structural_Diversity_Index_df)
