# This code is based on the work of Morgenroth et al. (2020) (DOI: 10.3390/f11020135)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import gaussian_kde

df = pd.read_csv("cleaned_master.csv", low_memory=False)
excluded_cities = ['Maple Ridge', 'New Westminster', 'Peterborough', 'Halifax']
df = df[~df['City'].isin(excluded_cities)]

# Ensure DBH is numeric and drop NaN values
df['DBH'] = pd.to_numeric(df['DBH'], errors='coerce')
df = df.dropna(subset=['DBH'])

# Create bins
bins = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, np.inf]
n_classes = 11 # Number of DBH classes for each city
bin_midpoints = [(bins[i] + bins[i+1]) / 2 for i in range(len(bins)-1)]

# Define cities
cities = df['City'].unique()

## Create histograms for the DBH distributions of each city (Urban Forest Diameter Class Distributions)
# Loop over each city to create histograms and curve plots
for city in cities:
    city_data = df[df['City'] == city]

    if len(city_data) == 0:
        continue  # Skip if there are no valid DBH values for the city

    # Create histogram with custom bins
    plt.figure(figsize=(8, 6))

    # Restrict x-axis to maximum of 150 cm
    sns.histplot(city_data['DBH'], bins=bins, kde=False, color='skyblue')

    # Fit and plot the KDE (Kernel Density Estimate) curve
    kde = gaussian_kde(city_data['DBH'])

    # Restrict the x-range for the KDE to be within the defined bin range
    x_range = np.linspace(0, 150, 1000)  # Limit the KDE to 150 cm
    plt.plot(x_range, kde(x_range) * len(city_data['DBH']) * (bins[1] - bins[0]), color='red', lw=2)

    # Set x-axis limit to match the bins
    plt.xlim(0, 150)

    # Add titles and labels
    plt.title(f'DBH Histogram with Curve for {city}')
    plt.xlabel('DBH (cm)')
    plt.ylabel('Frequency')

    # Show the plot
    plt.show()

## Comparison of Diameter Class Distributions Against Ideal Distributions
# Plot aggregated DBH distribution
plt.figure(figsize=(10, 6))
sns.histplot(df['DBH'], bins=bins, kde=False, color='skyblue', stat='density')

# Fit and plot a line of best fit (KDE curve)
kde = gaussian_kde(df['DBH'])
x_range = np.linspace(0, 150, 1000)
plt.plot(x_range, kde(x_range), color='red', lw=2, label='Aggregated DBH distribution (KDE)')

# Mid-points for ideal diameter class distributions from Richards and Millward & Sabir
richards_midpoints = [5, 15, 25, 35, 45, 55, 65, 75, 85, 95, 105, 115, 125, 135, 145]
millward_sabir_midpoints = [7.5, 17.5, 27.5, 37.5, 47.5, 57.5, 67.5, 77.5, 87.5, 97.5]

# Plot ideal midpoints (Richards)
plt.plot(richards_midpoints, np.full(len(richards_midpoints), 0.02), 'go-', label='Richards [15]')

# Plot ideal midpoints (Millward & Sabir)
plt.plot(millward_sabir_midpoints, np.full(len(millward_sabir_midpoints), 0.015), 'bo-', label='Millward & Sabir [11]')

# Add labels and title
plt.title('Figure 4: Aggregated DBH Distribution and Line of Best Fit for 38 Cities')
plt.xlabel('DBH (cm)')
plt.ylabel('Density')

# Show legend
plt.legend()

# Show the plot
plt.show()


## Structural Diversity Index
def calculate_shannon_wiener(city_data, bins, n_classes):
    # Classify trees into DBH classes using binning
    dbh_classes = pd.cut(city_data['DBH'], bins=bins, labels=range(1, len(bins)))

    # Calculate the proportion of trees in each class
    class_counts = dbh_classes.value_counts(normalize=True).sort_index()

    # Filter out zero proportions to avoid log(0)
    class_proportions = class_counts[class_counts > 0]

    # Calculate the Shannon-Wiener index (H)
    H = -np.sum(class_proportions * np.log(class_proportions))

    # Calculate H_max (maximum possible diversity)
    H_max = np.log(n_classes)

    return H, H_max


# Calculate Shannon-Wiener index for each city
city_results = []

cities = df['City'].unique()
for city in cities:
    city_data = df[df['City'] == city]

    if len(city_data) == 0:
        continue  # Skip if there are no valid DBH values for the city

    H, H_max = calculate_shannon_wiener(city_data, bins, n_classes)

    # Store the result for the city
    city_results.append({
        'City': city,
        'Shannon-Wiener Index (H)': H,
        'Maximum Diversity (H_max)': H_max
    })

# Convert results to a DataFrame for easy viewing
Structural_Diversity_Index_df = pd.DataFrame(city_results)
print(Structural_Diversity_Index_df)
